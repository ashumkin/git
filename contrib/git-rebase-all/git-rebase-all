#!/bin/sh
# vim: set noexpandtab tabstop=4 shiftwidth=4:

USAGE="[--all] [-x <excluded_branch>] [-n] [branch...]"
LONG_USAGE="git-rebase-all rebases all branches on top of theirs upstreams."

OPTIONS_KEEPDASHDASH=
OPTIONS_SPEC="\
git rebase-all $USAGE
--
a,all                rebase all branches
n,dry-run            don't do rebase
x,exclude=           don't rebase excluded branches
h,help               show this help"

. git-sh-setup

branches=()
excluded=()
all=0
dry_run=0

while test $# != 0
do
	arg="$1"
	shift
	case "$arg" in
		-a|-all)
			all=1
			;;
		-n|--dry-run)
			dry_run=1
			;;
		-x|--exclude)
			excluded[${#excluded[@]}]="$1"
			shift
			;;
		--)
			;;
		-h|--help)
			usage
			exit
			;;
		*)
			branches[${#branches[@]}]="$arg"
			;;
	esac
done

if test ${#branches[@]} -eq 0 -a $all -ne 1
then
	usage
fi

git status --porcelain --untracked-files=no --ignore-submodule=all | grep . && { echo dirty tree, exiting...; exit 1; }

REBASE_ALL_REF="refs/rebase-all/start"
branch=$(git symbolic-ref HEAD 2>/dev/null)
if test -z $branch
then
	echo You\'re not on any branch! Exiting >&2
	exit 3
fi

lastbranch=$(git symbolic-ref $REBASE_ALL_REF 2>/dev/null)
# if there is no last branch remembered
if test -z "$lastbranch"
then
	# remember the current branch
	git symbolic-ref $REBASE_ALL_REF "$branch"
	lastbranch="$branch"
fi
lastbranch=${lastbranch##refs/heads/}

# if no branches defined manually
if test $all -eq 1
then
	# read all branches
	branches=$(git for-each-ref '--format=%(refname:short)' refs/heads)
fi

function array_contains () {
	local a
	for a in "${@:2}"; do [[ "$a" == "$1" ]] && return 0; done
	return 1
}

function rebase_branch () {
	local br="$1"
	if array_contains "$br" "${excluded[@]}"
	then
		echo Skipping excluded branch $br
		return
	fi
	shift
	local upstream=$(git config branch.$br.remote)
	if test "$upstream" != "."
	then
		echo "Skipping remote tracking branch ($br tracks $upstream)" 1>&2
		return
	fi

	upstream=$(git config branch.$br.merge)
	if test -z "$upstream"
	then
		echo Skipping branch \"$br\" having no upstream 1>&2
		return
	fi

	local ups=${upstream/refs\/heads\/}
	# recursively rebase upstream, at first
	rebase_branch "$ups" $@

	upstream_id=$(git rev-parse "$upstream")
	b_id=$(git rev-parse "$br")
	merge_base=$(git merge-base $br $upstream_id)

	merge_ff=0
	if test "$merge_base" = "$b_id" -o "$merge_base" = "$upstream_id"
	then
		echo Branch \"$br\" not diverged with its upstream \"$ups\" 1>&2
		merge_ff=1
	fi

	echo checking out $br...
	git checkout "$br"
	if test $? -ne 0
	then
		echo FAILED!
		exit 1
	fi

	if test $dry_run -eq 0
	then
		if test "$merge_ff" -eq 1
		then
			echo Merging fast-forward...
			git merge --ff-only $@ @{u}
		else
			echo Rebasing $br...
			git rebase $@ @{u}
		fi
	else
		echo Test mode. No actual rebasing
	fi
	if test $? -ne 0
	then
		cat <<-EOF
		Rebasing seems to fail!
		Stopped to finish rebasing.
		Finish rebasing manually and run this script again.
EOF
		exit 2
	fi
}

for b in ${branches[@]}
do
	rebase_branch "$b" $@
done

git checkout "$lastbranch"
git symbolic-ref $REBASE_ALL_REF ""

echo "Done!"
